<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pixel Racer — Fixed Spawns</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  :root{
    --bg1:#05060a; --bg2:#0b0e18; --ink:#e6f7ff; --muted:#7fd0e0; --border:#00f0ff55;
    --neon1:#00f0ff; --neon2:#ff47ff; --lane:#0d1325; --card:#0a0d17f0;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;color:var(--ink);
    font-family:'Press Start 2P',system-ui,-apple-system,Segoe UI,Roboto,Arial;
    background:
      radial-gradient(1200px 700px at 20% -10%, #0d1b2a 0%, #0a0d17 35%, #05060a 100%),
      radial-gradient(800px 600px at 120% 120%, #210b24 0%, transparent 60%);
    display:flex;align-items:center;justify-content:center;padding:16px;
  }
  .wrap{width:min(94vw,900px)}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
  .title{font-size:clamp(18px,3vw,26px);text-shadow:0 2px 0 #000, 0 0 18px #00f0ff60}
  .btn{
    border:2px solid var(--border);background:linear-gradient(180deg,#0d1320,#090c16);
    color:var(--ink);padding:10px 14px;border-radius:12px;cursor:pointer;font-size:12px
  }
  .btn.primary{border-color:#00f0ff99;box-shadow:0 0 24px #00f0ffaa}
  .grid{display:grid;grid-template-columns:1fr 420px;gap:16px}
  @media (max-width:860px){.grid{grid-template-columns:1fr}}
  .card{background:var(--card);border:2px solid var(--border);border-radius:18px;padding:14px}
  .hud{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:10px}
  .pill{font-size:11px;padding:8px 10px;border:2px solid var(--border);border-radius:999px;background:#0c1221}
  .label{color:var(--muted);font-size:10px}
  .value{margin-left:8px}
  canvas{display:block;width:100%;height:auto;border-radius:16px;border:2px solid var(--border);background:#04060c}
  .side h3{margin:0 0 10px;font-size:14px;color:var(--muted)}
  ul{margin:0;padding-left:18px;font-size:11px;line-height:1.5}
  .kbd{border:2px solid var(--border);padding:3px 6px;border-radius:8px;font-size:10px;background:#0b1020}
  footer{margin-top:10px;color:#8bd0ff88;font-size:10px;text-align:center}
  .tapzones{position:absolute;inset:0;display:none}
  .zone{position:absolute;top:0;bottom:0}
  .zone.left{left:0;width:33%}
  .zone.mid{left:33%;right:33%}
  .zone.right{right:0;width:33%}
  @media (hover:none){.tapzones{display:block}}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="title">Pixel Racer</div>
    <div style="display:flex;gap:8px">
      <button id="btnPause" class="btn">Pause</button>
      <button id="btnReset" class="btn primary">Restart</button>
    </div>
  </header>

  <div class="grid">
    <div class="card" style="position:relative">
      <div class="hud">
        <div class="pill"><span class="label">Score</span><span id="score" class="value">00000</span></div>
        <div class="pill"><span class="label">High</span><span id="best" class="value">00000</span></div>
        <div class="pill"><span class="label">Speed</span><span id="speed" class="value">0</span></div>
      </div>
      <div style="position:relative">
        <canvas id="game" width="420" height="700"></canvas>
        <div class="tapzones" id="tapzones">
          <div class="zone left"></div><div class="zone mid"></div><div class="zone right"></div>
        </div>
      </div>
    </div>

    <div class="card side">
      <h3>How to play</h3>
      <ul>
        <li>Move: <span class="kbd">←</span>/<span class="kbd">→</span> or <span class="kbd">A</span>/<span class="kbd">D</span></li>
        <li>Pause: <span class="kbd">P</span></li>
        <li>Mobile: tap left/right; center to pause</li>
      </ul>
      <p style="margin-top:10px;font-size:11px;color:#9fe0ffcc">
        Dodge pink traffic, collect yellow coins, survive as speed ramps up.
      </p>
    </div>
  </div>

  <footer>No libraries. 100% in-browser canvas.</footer>
</div>

<script>
(()=>{
// ===== Constants
const W=420,H=700, LANES=3, LANE_W=W/LANES, MARGIN=18;
const PLAYER_W=34,PLAYER_H=54, CAR_W=34,CAR_H=54, COIN=16;
const COLORS={ lane:'#0e1430', line:'#18224d', dash:'#1e2b63', player:'#7fd0e0', enemy:'#ff47ff', coin:'#ffed5a', text:'#e6f7ff' };
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const laneX=i=>Math.floor(i)*LANE_W + LANE_W/2;
const rnd=(a,b)=>Math.random()*(b-a)+a;

// ===== State
let ctx, paused=false, last=0;
const START=3, MAX=9;
let speed, score, best=+localStorage.getItem('pxr_best')||0;
let player, cars=[], coins=[];

// --- spawn pacing (per-lane + global) ---
let laneEnemyCD=[0,0,0];
let laneCoinCD=[0,0,0];
let globalCarCD=0;
let lastCarLane=-1;
const CAR_MIN_GAP_BASE=150;
const CAR_MIN_GAP_PER_SPEED=7;
const CAR_SPAWN_MIN_DELAY=0.28; // seconds between any two car spawns
const CAR_SOFT_CAP=12;

// ===== Setup/Reset
function reset(){
  speed=START; score=0;
  cars.length=0; coins.length=0;
  laneEnemyCD=[0,0,0]; laneCoinCD=[0,0,0]; globalCarCD=0; lastCarLane=-1;
  player={lane:1,x:laneX(1)-PLAYER_W/2,y:H-PLAYER_H-28,w:PLAYER_W,h:PLAYER_H};
  paused=false; updateHUD();
}

// ===== Draw
function drawRoad(){
  ctx.fillStyle=COLORS.lane; ctx.fillRect(MARGIN,0,W-MARGIN*2,H);
  ctx.strokeStyle=COLORS.line; ctx.lineWidth=2;
  for(let i=1;i<LANES;i++){ const x=LANE_W*i; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  ctx.strokeStyle=COLORS.dash; ctx.lineWidth=6; ctx.setLineDash([18,22]);
  ctx.lineDashOffset=-(score/4)%40; ctx.beginPath();
  ctx.moveTo(laneX(1),0); ctx.lineTo(laneX(1),H); ctx.stroke(); ctx.setLineDash([]);
}
function rect(x,y,w,h,c){ ctx.fillStyle=c; ctx.fillRect(x,y,w,h); ctx.strokeStyle='#0008'; ctx.strokeRect(x+.5,y+.5,w-1,h-1); }
function carSprite(e){ rect(e.x,e.y,e.w,e.h, COLORS.enemy); }
function coinSprite(c){ ctx.fillStyle=COLORS.coin; ctx.beginPath(); ctx.arc(c.x+c.s/2,c.y+c.s/2,c.s/2,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#0008'; ctx.stroke(); }

// ===== Spawning
function canSpawnInLane(lane, list, newY, minGap){
  let latest=null;
  for(const e of list){ if(e.lane===lane && (!latest || e.y>latest.y)) latest=e; }
  if(!latest) return true;
  return (newY - latest.y) >= minGap;
}
function spawnCarLane(lane){
  const y=-CAR_H-10;
  const minGap = CAR_MIN_GAP_BASE + speed*CAR_MIN_GAP_PER_SPEED;
  if(!canSpawnInLane(lane, cars, y, minGap)) return false;

  cars.push({lane, x:laneX(lane)-CAR_W/2, y, w:CAR_W, h:CAR_H, v:speed + rnd(.6,1.8)});
  laneEnemyCD[lane] = Math.max(0.40, rnd(0.80,1.10) - speed*0.03);
  globalCarCD = CAR_SPAWN_MIN_DELAY;
  lastCarLane = lane;
  return true;
}
function spawnCoinPattern(lane){
  const y=-COIN-8, step=44, r=Math.random();
  // require small gap from last coin in lane
  if(!canSpawnInLane(lane, coins, y, 100 + speed*4)) return;
  if(r<0.5){ coins.push({lane,x:laneX(lane)-COIN/2,y,s:COIN}); }
  else { const n=(r<0.8?2:3); for(let k=0;k<n;k++) coins.push({lane,x:laneX(lane)-COIN/2,y:y-k*step,s:COIN}); }
}

// ===== Logic
function hit(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }
function toLaneX(l){ return laneX(l)-PLAYER_W/2; }

function update(dt){
  if(paused) return;
  // ramp
  speed = Math.min(MAX, speed + dt*0.05);

  // tick cooldowns
  globalCarCD = Math.max(0, globalCarCD - dt);
  for(let i=0;i<LANES;i++){
    laneEnemyCD[i]=Math.max(0,laneEnemyCD[i]-dt);
    laneCoinCD[i]=Math.max(0,laneCoinCD[i]-dt);
  }

  // CAR SPAWNING (staggered)
  if(cars.length < CAR_SOFT_CAP && globalCarCD===0){
    const candidates=[];
    for(let i=0;i<LANES;i++){
      if(laneEnemyCD[i]===0){
        // bias against same or adjacent lane as the last car (reduces walls)
        const adjPenalty = (lastCarLane>=0 && Math.abs(i-lastCarLane)<=1) ? 0.45 : 0.0;
        if(Math.random()>adjPenalty) candidates.push(i);
      }
    }
    if(candidates.length){
      const lane = candidates[(Math.random()*candidates.length)|0];
      spawnCarLane(lane);
    }
  }

  // COINS
  for(let i=0;i<LANES;i++){
    if(laneCoinCD[i]===0 && Math.random()<0.40){
      spawnCoinPattern(i);
      laneCoinCD[i] = 0.70 + Math.random()*0.40;
    }
  }

  const v = 60*dt;
  cars.forEach(e=> e.y += (e.v)*v/10);
  coins.forEach(c=> c.y += speed*v/10);

  // collisions
  for(let i=coins.length-1;i>=0;i--){
    const c=coins[i];
    if(c.y>H+8){ coins.splice(i,1); continue; }
    if(hit(player,{x:c.x,y:c.y,w:c.s,h:c.s})){ coins.splice(i,1); score+=25; }
  }
  for(let i=cars.length-1;i>=0;i--){
    const e=cars[i];
    if(e.y>H+CAR_H){ cars.splice(i,1); continue; }
    if(hit(player,e)){
      paused=true; // game over
      best=Math.max(best,score); localStorage.setItem('pxr_best',best);
    }
  }

  score += (speed*2|0);
}

function draw(){
  ctx.clearRect(0,0,W,H);
  drawRoad();
  cars.forEach(carSprite);
  coins.forEach(coinSprite);
  rect(player.x,player.y,player.w,player.h, COLORS.player);
  ctx.fillStyle='#7fd0e0aa'; ctx.font='10px "Press Start 2P"';
  ctx.fillText('← → Move | P Pause', 10, 16);
}

// ===== HUD & Controls
function updateHUD(){
  document.getElementById('score').textContent=String(score).padStart(5,'0');
  document.getElementById('best').textContent=String(best).padStart(5,'0');
  document.getElementById('speed').textContent=(speed*10|0);
}
function move(dir){ player.lane=clamp(player.lane+dir,0,LANES-1); player.x=toLaneX(player.lane); }
function togglePause(){ paused=!paused; document.getElementById('btnPause').textContent=paused?'Resume':'Pause'; if(!paused){ last=performance.now(); requestAnimationFrame(loop); } }

// ===== Loop
function loop(now){
  const dt=Math.min(0.05,(now-last)/1000||0); last=now;
  update(dt); draw(); updateHUD();
  if(paused){
    ctx.fillStyle='#0009'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle=COLORS.text; ctx.textAlign='center'; ctx.font='20px "Press Start 2P"';
    ctx.fillText('Paused',W/2,H/2-10); ctx.font='12px "Press Start 2P"'; ctx.fillText('Press P or Resume',W/2,H/2+18);
    ctx.textAlign='left'; return;
  }
  requestAnimationFrame(loop);
}

// ===== Boot
function init(){
  const c=document.getElementById('game'); ctx=c.getContext('2d');
  reset(); last=performance.now(); requestAnimationFrame(loop);

  // keys
  addEventListener('keydown',e=>{
    if(e.repeat) return;
    if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') move(-1);
    else if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') move(1);
    else if(e.key==='p'||e.key==='P') togglePause();
  });

  // buttons
  document.getElementById('btnPause').onclick=togglePause;
  document.getElementById('btnReset').onclick=()=>{ reset(); if(paused) togglePause(); };

  // mobile taps
  const tz=document.getElementById('tapzones');
  tz.addEventListener('touchend',e=>{
    const x=(e.changedTouches[0]||{}).clientX, w=tz.clientWidth;
    if(x<w*0.33) move(-1); else if(x>w*0.66) move(1); else togglePause();
  },{passive:true});
}
window.addEventListener('load',init);
})();
</script>
</body>
</html>
